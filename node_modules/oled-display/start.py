import sys
import json
import random
import signal
import math
import uuid
import random

#import OPi.GPIO as GPIO
import time

# Adafruit
import Adafruit_GPIO.SPI as SPI
import Adafruit_SSD1306

# luma.oled
from luma.core.interface.serial import i2c, spi
from luma.oled.device import ssd1306, ssd1309, ssd1322, ssd1325, ssd1327, ssd1331, ssd1351, sh1106

from PIL import Image
from PIL import ImageDraw
from PIL import ImageFont

from luma.core.render import canvas

import PIL.ImageOps  

# Raspberry Pi pin configuration:
RST = None

# 128x32 display with hardware I2C:
disp = None
draw = None
images = {}
image = None
image_ver = None
image_hor = None
fonts = {'default_12': PIL.ImageFont.truetype('./fonts/UbuntuMono-Regular.ttf', 12)}#ImageFont.load_default()
fonts['default'] = fonts['default_12']
font = fonts['default_12']
invert_display = False
backend = 'adafruit'

# 128x64 display with hardware I2C:
#disp = Adafruit_SSD1306.SSD1306_128_64(rst=RST)

# Initialize library.
#disp.begin()

# Clear display.
#disp.clear()
#disp.display()

def printError(message, recoverable):
  print(json.dumps({
    "type": "python_error_recoverable" if recoverable else "python_error",
    "message": 'Python, ' + str(message)
  }));
  
class BackendException(Exception):
   """Base class for other exceptions"""
   pass

def start():
  global disp, draw, image
  
  # Create blank image for drawing.
  # Make sure to create image with mode '1' for 1-bit color.

  

  # Draw a black filled box to clear the image.
  #draw.rectangle((0,0,width,height), outline=0, fill=0)

  #draw.polygon([(20, 20), (30, 2), (40, 20)], outline=255, fill=1)  #Up filled
  #disp.display();

  #draw.rectangle((0,0,10,10), outline=0, fill=1)

  #font = ImageFont.load_default()
  #font = ImageFont.truetype('Minecraftia.ttf', 8)
  
  #font.getSize('text') # returns width height

  #disp.image(image)
  #disp.display()
  #print('out eS')
  
# Microfont
mfLetters = {
 ' ': 0b0000000000000000,
 '0': 0b1111011011011110,
 '1': 0b1100100100101110,
 '2': 0b1100010101001110,
 '3': 0b1100011110011100,
 '4': 0b1001001011110010,
 '5': 0b1111001110011100,
 '6': 0b0111001101011110,
 '7': 0b1110010100100100,
 '8': 0b1111011111011110,
 '9': 0b1111011110011110,
 'a': 0b0000111011010110,
 'b': 0b1001101011011100,
 'c': 0b0000111001000110,
 'd': 0b0010111011010110,
 'e': 0b0000111011100110,
 'f': 0b0101011001101000,
 'g': 0b0101010110011100,
 'h': 0b1001001101011010,
 'i': 0b0100000100100100,
 'j': 0b0010000010011100, #0b0100000100101000
 'k': 0b0001011011101010, #0b1001011101011010,
 'l': 0b0100100100100010,
 'm': 0b0001011111011010,
 'n': 0b0001101011011010,
 'o': 0b0000101011010100,
 'p': 0b1101011011101000,
 'q': 0b0111011010110010,
 'r': 0b0001011101001000,
 's': 0b0000111100011100,
 't': 0b1001101001000110,
 'u': 0b0001011011010110,
 'v': 0b0001011010100100,
 'w': 0b0001011011111010,
 'x': 0b0001010101011010,
 'y': 0b1011010110010100,
 'z': 0b0001110010101110,
 'A': 0b0111011111011010,
 'B': 0b0111011101011100,
 'C': 0b0111001001000110,
 'D': 0b1101011011011100,
 'E': 0b0111001111001110,
 'F': 0b0111001111001000,
 'G': 0b0111001011010110,
 'H': 0b1011011111011010,
 'I': 0b1110100100101110,
 'J': 0b0110010011010100,
 'K': 0b1011011101011010,
 'L': 0b1001001001001110,
 'M': 0b1011111111011010,
 'N': 0b1101011011011010,
 'O': 0b0101011011010100,
 'P': 0b1101011111001000,
 'Q': 0b0111011011010110,
 'R': 0b0111011101011010,
 'S': 0b0111000100011100,
 'T': 0b1110100100100100,
 'U': 0b1011011011010110,
 'V': 0b1011011011010100,
 'W': 0b1011011011111010,
 'X': 0b1011010101011010,
 'Y': 0b1011010100100100,
 'Z': 0b1110010101001110,
 '`': 0b0100010000000000,
 '~': 0b0100100101110100,
 '!': 0b0100100100000100,
 '@': 0b0101011011000110,
 '#': 0b1011111011111010,
 '$': 0b0111101110111100,
 '%': 0b1010010101001010,
 '^': 0b0101110100100100,
 '*': 0b1010101010000000,
 '(': 0b0010100100100010,
 ')': 0b0100010010010100,
 '+': 0b0000101110100000,
 '\'': 0b0100100000000000,
 '-': 0b0000001110000000,
 '_': 0b0000000000001110,
 '.': 0b0000000000000100,
 '/': 0b0010010101001000,
 ':': 0b0000100000100000,
 ';': 0b0000100000101000,
 '<': 0b0010101000100010,
 '=': 0b0001110001110000,
 '>': 0b1000100010101000,
 '?': 0b1110010100000100,
 '"': 0b1011010000000000,
 '[': 0b0110100100100110,
 '\\': 0b1001000100010010,
 ']': 0b1100100100101100,
 '{': 0b0110101100100110,
 '}': 0b1100100110101100,
 '|': 0b0100100100100100,
 ',': 0b0000000000101000,
 '&': 0b0111100111100110,
 'Â£': 0b1111111111111111
}

mfData = {
  'g': { 'yoffset': 1 },
  'g': { 'yoffset': 1 },
  'j': { 'yoffset': 1 },
  'p': { 'yoffset': 1 },
  'q': { 'yoffset': 1 },
  'y': { 'yoffset': 1 },
}

class Backend(object):
  def __init__(self):
    self.rotation = 0
    self.message = {}
    self.resetFlag = False
    #self.readyFlag = True
    self.backend = 'adafruit'
    
  #def sync(self, args):
  #  return (not self.resetFlag)# and self.readyFlag

  def handle(self, function, args):
    """Dispatch method"""
    method_name = str(function)
    # Get the method from 'self'. Default to a lambda.
    if not hasattr(self, method_name):
      raise BackendException('Backend Error: Unknown function: ', function) 
    else:
      method = getattr(self, method_name, lambda: "Error: Unknown function")
    
    # Call the method as we return it
    return method(args)

  def init(self, args):
    global disp, image, image_hor, image_ver, draw
    driver = args['driver']
    interface = args['interface']
    self.mode = '1'
    self.bits = 1
    
    if interface == 'I2C':
      if driver == 'SSD1306_128_64':
        disp = Adafruit_SSD1306.SSD1306_128_64(rst=RST, i2c_bus=args['i2c_bus'], i2c_address=args['i2c_address'])
      elif driver == 'SSD1306_128_32':
        disp = Adafruit_SSD1306.SSD1306_128_32(rst=RST, i2c_bus=args['i2c_bus'], i2c_address=args['i2c_address'])
      elif driver == 'ssd1309_128_64':
        self.backend = 'luma.oled'
        disp = ssd1309(i2c(port=args['i2c_bus'], address=args['i2c_address']))
      #elif driver == 'ssd1322_256_64':
      #  self.backend = 'luma.oled'
      #  disp = ssd1322(i2c(port=args['i2c_bus'], address=args['i2c_address']))
      #elif driver == 'ssd1325_128_64':
      #  self.backend = 'luma.oled'
      #  disp = ssd1325(i2c(port=args['i2c_bus'], address=args['i2c_address']))
      elif driver == 'SSD1327_128_128':
        self.backend = 'luma.oled'
        self.mode = 'RGB'
        self.bits = 8
        disp = ssd1327(i2c(port=args['i2c_bus'], address=args['i2c_address']))
      #elif driver == 'SSD1331_96_64': #
      #  self.backend = 'luma.oled'
      #  self.bits = 16
      #  disp = ssd1331(i2c(port=args['i2c_bus'], address=args['i2c_address']))
      #elif driver == 'SSD1351_128_96': #
      #  self.backend = 'luma.oled'
      #  self.bits = 16
      #  disp = ssd1351(i2c(port=args['i2c_bus'], address=args['i2c_address']))
      elif driver == 'SSH1106_128_64':
        self.backend = 'luma.oled'
        disp = ssh1106(i2c(port=args['i2c_bus'], address=args['i2c_address']))
    elif interface == 'SPI':
      if driver == 'SSD1306_128_64':
        disp = Adafruit_SSD1306.SSD1306_128_64(rst=args['spi_rst_pin'], dc=args['spi_dc_pin'], spi=SPI.SpiDev(args['spi_port'], args['spi_device']), max_speed_hz=args['spi_hz'])
      elif driver == 'SSD1306_128_32':
        disp = Adafruit_SSD1306.SSD1306_128_32(rst=args['spi_rst_pin'], dc=args['spi_dc_pin'], spi=SPI.SpiDev(args['spi_port'], args['spi_device']), max_speed_hz=args['spi_hz'])
      elif driver == 'ssd1309_128_64':
        self.backend = 'luma.oled'
        disp = ssd1309(spi(device=args['spi_device'], port=args['spi_port']))
      elif driver == 'ssd1322_256_64':
        self.backend = 'luma.oled'
        disp = ssd1322(spi(device=args['spi_device'], port=args['spi_port']))
      elif driver == 'ssd1325_128_64':
        self.backend = 'luma.oled'
        disp = ssd1325(spi(device=args['spi_device'], port=args['spi_port']))
      elif driver == 'SSD1327_128_128':
        self.backend = 'luma.oled'
        self.mode = 'RGB'
        self.bits = 8
        disp = ssd1327(spi(device=args['spi_device'], port=args['spi_port']))
      elif driver == 'SSD1331_96_64': #
        self.backend = 'luma.oled'
        self.bits = 16
        disp = ssd1331(spi(device=args['spi_device'], port=args['spi_port']))
      elif driver == 'SSD1351_128_96': #
        self.backend = 'luma.oled'
        self.bits = 16
        disp = ssd1351(spi(device=args['spi_device'], port=args['spi_port']))
      elif driver == 'SSH1106_128_64':
        self.backend = 'luma.oled'
        disp = ssh1106(spi(device=args['spi_device'], port=args['spi_port']))
    
    self.maxValue = 1
    if 'RGB' == self.mode:
      self.maxValue = 255
    
    if 'adafruit' == self.backend:
      disp.begin()
    
    self.rotate({})
    width = self.getOutputWidth()
    height = self.getOutputHeight()
    #image_hor = Image.new('1', (width, height))
    #image_ver = Image.new('1', (width, width))
    image = Image.new(self.mode, (width, width))
    
    images['default'] = image;

    # Get drawing object to draw on image.
    draw = ImageDraw.Draw(image)
    
    #start()
    
    """f = open("out.txt", "a")
    
    for key in mfLetters:
      bitstr = ''
      for value in mfLetters[key]:
        bitstr += (bin(value)[2:]).zfill(8)
      
      f.write(" '" + key + "': 0b" + bitstr + ",\n")
    f.close()"""
    
  def reinit(self, args):
    global disp, draw
    if 'adafruit' in self.backend:
      disp.begin()
    #disp.reset()

  def clear(self, args):
    global disp, draw
    #disp.clear()
    draw.rectangle((0, 0, self.getWidth(), self.getHeight()), fill=args.get('fill', 0))

  def rotate(self, args):
    global image, image_hor, image_ver, draw
    
    rotation = args.get('value', 0)
  
    # If rotation changes from horizontal to vertical
    #if (self.rotation == 0 or self.rotation == 180) and (rotation == 90 or rotation == 270):
      #image = image_ver
      #draw = ImageDraw.Draw(image)
      
    # If rotation changes from vertical to horizontal
    #if (self.rotation == 90 or self.rotation == 270) and (rotation == 0 or rotation == 180):
      #image = image_hor
      #draw = ImageDraw.Draw(image)
      
    if rotation == 0 or rotation == 180:
      self.width = self.getOutputWidth()
      self.height = self.getOutputHeight()
    elif rotation == 90 or rotation == 270:
      self.width = self.getOutputHeight()
      self.height = self.getOutputWidth()
      
    self.rotation = rotation

  def render(self, args):
    global disp, draw, image, invert_display
    invert = args.get('invert', False)
   
    #a = time.time()*1000
    #for pixel in iter(image.getdata()):
    
    ###########
    """pixels = [] # For inked pixels (text, etc)
    for y in range(self.getHeight()):
      for x in range(self.getWidth()):
        pixel = image.getpixel((x, y))
        if pixel == 1:
          pixels.append(x)
          pixels.append(y)
          
    draw.rectangle((0, 0, self.getWidth(), self.getHeight()), fill=1)
    draw.point(pixels, fill=0)"""
    imageArr = image.load()
    if invert_display:
      if self.bits == 1:
        for y in range(self.getHeight()):
          for x in range(self.getWidth()):
            imageArr[x, y] = self.maxValue - imageArr[x, y]
      elif self.bits == 8:
        for y in range(self.getHeight()):
          for x in range(self.getWidth()):
            color = imageArr[x, y]
            imageArr[x, y] = (self.maxValue - color[0], 0, 0)
      elif self.bits == 16:
        for y in range(self.getHeight()):
          for x in range(self.getWidth()):
            color = imageArr[x, y]
            imageArr[x, y] = (self.maxValue - color[0], self.maxValue - color[1], self.maxValue - color[2])

    #image2.paste(image, box=(30,0), mask=image)
    if self.rotation == 0:
      temp = image.crop((0, 0, self.getOutputWidth(), self.getOutputHeight()))
    elif self.rotation == 180:
      temp = image.crop((0, 0, self.getOutputWidth(), self.getOutputHeight())).rotate(180)
    elif self.rotation == 90:
      temp = image.rotate(270).crop((0, 0, self.getOutputWidth(), self.getOutputHeight()))
    elif self.rotation == 270:
      temp = image.rotate(270).crop((0, 0, self.getOutputWidth(), self.getOutputHeight())).rotate(180)

    if ('adafruit' in self.backend):
      disp.image(temp)
      
    if (invert):
      self.setInvert({'enable': True})
    #self.readyFlag = False
    if ('adafruit' in self.backend):
      disp.display()
    elif ('luma.oled' in self.backend):
      disp.display(temp)
      
    #with canvas(disp) as dd:
    #  dd.rectangle(disp.bounding_box, outline="white", fill="black")
    #self.readyFlag = True
    #print(time.time()*1000 - a)
    return (not self.resetFlag)
    
  def drawFuzz(self, args):
    imageArr = image.load()
    if self.bits == 1:
      for y in range(self.getHeight()):
        for x in range(self.getWidth()):
          imageArr[x, y] = random.randrange(1 + self.maxValue)
    elif self.bits == 8:
      for y in range(self.getHeight()):
        for x in range(self.getWidth()):
          color = imageArr[x, y]
          imageArr[x, y] = (255 if random.randrange(2) == 1 else 0, 0, 0)
    elif self.bits == 16:
      for y in range(self.getHeight()):
        for x in range(self.getWidth()):
          color = imageArr[x, y]
          imageArr[x, y] = (random.randrange(1 + self.maxValue), random.randrange(1 + self.maxValue), random.randrange(1 + self.maxValue))

  def setInvert(self, args):
    global invert_display
    invert_display = args['enable']
    
  def drawInvertRectangle(self, args):
    global disp, draw

    x1 = args['x1']
    y1 = args['y1']
    x2 = args['x2']
    y2 = args['y2']
    
    imageArr = image.load()
    if self.bits == 1:
      for y in range(y1, y2):
        for x in range(x1, x2):
          imageArr[x, y] = self.maxValue - imageArr[x, y]
    elif self.bits == 8:
      for y in range(y1, y2):
        for x in range(x1, x2):
          color = imageArr[x, y]
          imageArr[x, y] = (self.maxValue - color[0], 0, 0)
    elif self.bits == 16:
      for y in range(y1, y2):
        for x in range(x1, x2):
          color = imageArr[x, y]
          imageArr[x, y] = (self.maxValue - color[0], self.maxValue - color[1], self.maxValue - color[2])

  def drawInvertRectangleSize(self, args):
    global disp, draw

    x1 = args['x']
    y1 = args['y']
    x2 = x1 + args['width']
    y2 = y1 + args['height']
    drawInvertRectangle({'x1': x1, 'y1': y1, 'x2': x2, 'y2': y2})
   
  def setDim(self, args):
    global disp, draw
    value = 1 if args['enable'] else 255
    self.setContrast({'value': value})
    
  def setContrast(self, args):
    global disp, draw
    value = args['value']
    
    if 'adafruit' in self.backend:
      disp.set_contrast(value)
    elif 'luma.oled' in self.backend:
      disp.contrast(value)    
  
  def getOutputWidth(self):
    return disp.width
    
  def getOutputHeight(self):
    return disp.height
    
  def getWidth(self):
    return self.width
    
  def getHeight(self):
    return self.height
    
  def drawRectangle(self, args):
    global disp, draw
    x1, y1, x2, y2 = args['x'], args['y'], args['x2'], args['y2']
    draw.rectangle((x1, y1, x2, y2), outline=args.get('outline', 0), fill=args.get('fill', 1))

  def drawRectangleSize(self, args):
    global disp, draw
    x1, y1, x2, y2 = args['x'], args['y'], args['x'] + args['width'], args['y'] + args['height']
    draw.rectangle((x1, y1, x2, y2), outline=args.get('outline', 0), fill=args.get('fill', 1))

  def drawLine(self, args):
    global disp, draw
    draw.line([args.get('x1', 0), args.get('y1', 0), args.get('x2', 0), args.get('y2', 0)], fill=args.get('fill', 1))

  def drawLineDashHor(self, args):
    global disp, draw
    x, y, length = args.get('x', 0), args.get('y', 0), args['length']
    
    for i in range(args.get('offset', 0), length, args.get('spacing', 2)):
      draw.point((x + i, y), fill=args.get('fill', 1))
      
  def drawLineDashVer(self, args):
    global disp, draw
    x, y, length = args.get('x', 0), args.get('y', 0), args['length']
    
    for i in range(args.get('offset', 0), length, args.get('spacing', 2)):
      draw.point((x, y + i), fill=args.get('fill', 1))

  def drawPoint(self, args):
    global disp, draw
    draw.point((args.get('x', 0), args.get('y', 0)), fill=args.get('fill', 1))
    
  def drawPoints(self, args):
    global disp, draw
    draw.point(args.get('points', []), fill=args.get('fill', 1))
    
  def drawPolygon(self, args):
    global disp, draw
    points = []
    data = args['points']
    for i in range(0, len(data), 2):
      points.append((data[i], data[i + 1]))
      #print('{"type": "none", "msg": "',str(data[i]) + '_' + str(data[i + 1]),'"}')
    
    draw.polygon(points, outline=args.get('outline', 1), fill=args.get('fill', 1))

  def drawCircle(self, args):
    global disp, draw
    outline = args.get('outline', 0)
    radius = args.get('radius', 1)
    x = args.get('x', 0)
    y = args.get('y', 0)
    draw.ellipse((x - radius, y - radius, x + radius, y + radius), outline=args.get('outline', 1), fill=args.get('fill', 1))

  def newTarget(self, args):
    global disp, images
    width = self.getOutputWidth()
    
    image = Image.new('L', (width, width))
    id = str(uuid.uuid4())
    images[id] = image
    return id
    
  def setTarget(self, args):
    global draw, image
    target = images[args['id']]
    image = target
    draw = ImageDraw.Draw(target)
    
  def resetTarget(self, args):
    self.setTarget({'id': 'default'});
    
  def drawTarget(self, args):
    global disp, draw, images
    x = args['x']
    y = args['y']
    width = args['width']
    height = args['height']
    image.paste(images[args['id']], box=(x, y), mask=images[args['id']])

  def loadImage(self, args):
    global disp, images
    path = args['path']
    image = Image.open(path).convert(self.mode)
    #image.resize((self.getWidth(), self.getHeight()), Image.ANTIALIAS).convert('1')
    id = str(uuid.uuid4())
    images[id] = image
    return id
    
  def drawImage(self, args):
    global disp, draw, images
    #images[args['id']].paste(image)
    #image.paste(images[args['id']])
    #disp.image(image)
    
    #draw_base.rectangle((0,0,self.getWidth(), self.getHeight()), outline=0, fill=0)
    #image_overlay.putdata(image.getdata())
    image.paste(images[args['id']], box=(0,0), mask=images[args['id']])
      
    #disp.image(image)
    #disp.image(images[args['id']])

  def loadFont(self, args):
    global disp, draw, fonts
    font = ImageFont.truetype(args['path'], args.get('size', 8), encoding="unic")
    fonts[args['name']] = font
    
  def setFont(self, args):
    global disp, draw, fonts, font
    #if not fonts[args('name', 'undefined')]:
    #  raise Exception('Error: Unknown font: ', args('name', 'undefined'))
    
    font = fonts[args['name']]
    
  def getFontWidth(self, args):
    global disp, draw, fonts, font
    w, h = font.getsize(args['message'])
    return w
    
  def getFontHeight(self, args):
    global disp, draw, fonts, font
    w, h = font.getsize(args['message'])
    return h
    
  def drawText(self, args):
    global disp, draw, font
    lastFont = font
    if args.get('font', None):
      setFont(self, {
        'font': args['font']
      })
    
    x = args.get('x', 0)
    y = args.get('y', 0)
    wrap = args.get('wrap', True)
    halign = args.get('halign', 1)
    valign = args.get('valign', 1)
    vspacing = args.get('vspacing', 2)
    (_x, _y), (offset_x, offset_y) = font.font.getsize('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz')
    
    temp = ''
    i = 0
    str = args.get('message', '')
    for char in str:
      if char != '\n':
        temp += char
      else:
        temp = ''
      
      w, h = font.getsize(temp)
      
      if wrap:
        if (halign == 1 and x + w >= self.getWidth()) or (halign == -1 and x - w < 0) or (halign == 0 and (x - w/2 < 0 or x + w/2 >= self.getWidth())):
          str = str[:i] + '\n' + str[i:]
          temp = ''
          
        i += 1
      
    i = 0
    for line in str.split('\n'):
      ascent, descent = font.getmetrics()
      (_x, _y, w, _h) = font.getmask(line).getbbox()
      xi = x
      yi = y
      
      h = ascent - offset_y
      totalHeight = (1 + str.count('\n')) * (h + vspacing)
      #print(offset_y)
      #print(totalHeight)
      #descent -= 1

      if halign == 1:
        xi = xi
      elif halign == -1:
        xi = xi - w
      elif halign == 0:
        xi = xi - math.floor(w / 2)
      #print('{"message":"', offset_x,'"}')
      if valign == 1:
        yi = yi + ((h + vspacing) * i) - offset_y
      elif valign == -1:
        yi = yi - totalHeight + ((h + vspacing) * i)
        #yi = yi - ((h + vspacing) * i) - (h * (str.count('\n')+1))
        #yi = yi - (h + descent) * (i + 1)
      elif valign == 0:
        yi = yi - (totalHeight / 2) + ((h + vspacing) * i)
        #yi = yi + (h * i) - (h * (str.count('\n')))/2 - 1
      
      draw.text((xi, yi), line, font=font, fill=args.get('fill', 1))
      #print('{"message":"', (h + descent),'"}')
      i += 1
      
    font = lastFont
    
  def drawTextMicro(self, args):
    global disp, draw, font
    drawByteString(mfLetters, args.get('fill', 1), args.get('message', ''), args.get('x', 0), args.get('y', 0), 3, 5, args.get('wrap', True), args.get('halign', -1), args.get('valign', -1), args.get('padding', 1), args.get('vspacing', 3))

Backend = Backend()

def drawByteChar(imageArr, data, x, y, width, height, fill):
  #if data > 400 or data < 5:
  #  return

  if (data == 0): # Empty space    
    return
    
  #print('{"message1":"', data,'"}')

  # To bitstr
  pos = int(16 - math.log(data, 2))
  #x = data & (1 << 16 - (pos + 2))
  
  """bitstr = ''
  bitstr = '{:08b}'.format(data)
  print('{"message1":"', bitstr.zfill(16),'"}')
  #print('{"message2":"', bin(data)[2:],'"}')
  print('{"message2":"', "log ", pos, " ", x,'"}')"""
  
  #imageArr = image.load()
  
  #points = []
  i = 0
  for iy in range(height):
    for ix in range(width):
      if i + 1 >= pos:
        if data & (1 << 15 - i) > 0 and x + ix < Backend.getWidth() and y + iy < Backend.getHeight():
          imageArr[x + ix, y + iy] = fill
          ##points.append(x + ix)
          ##points.append(y + iy)
          #raw.point((x + ix, y + iy), fill=fill)
      i += 1
      
  #draw.point(points, fill=fill)
  
  #time.sleep(2000);
  #for value in data:
  #  bitstr += (bin(value)[2:]).zfill(8);
  #print(bitstr)

  """i = 0
  for iy in range(height):
    for ix in range(width):
      #print(bitstr[i])
      if bitstr[i] == '1':
        draw.point((x + ix, y + iy), fill=fill)
      i += 1"""
    
  #print('')
  #print(type( bin(mfLetters['#'][0])[2:] ))
  #for b in bits(arr[0]):
  #  print(b)
  #draw.point((x, y), fill=1)
  
def drawByteString(arr, fill, str, x, y, width, height, wrap, halign, valign, padding, vspacing):
  imageArr = image.load()
  temp = ''
  i = 0
  
  for char in str:
    if char != '\n':
      temp += char
    else:
      temp = ''
    
    w, h = width * len(temp) + len(temp), height + 1
    
    if wrap:
      if (halign == 1 and x + w >= Backend.getWidth()) or (halign == -1 and x - w < 0) or (halign == 0 and (x - w/2 < 0 or x + w/2 >= Backend.getWidth())):
        str = str[:i] + '\n' + str[i:]
        
        #print('index: ', i)
        #i += 1
        temp = ''
        
      i += 1
  
  # Draw char
  i = 0
  for line in str.split('\n'):
    styleBlock = '/b/' in line
    line = line.replace('/b/', '')
    styleUnderdash = '/d/' in line
    line = line.replace('/d/', '')
    styleUnderline = '/u/' in line
    line = line.replace('/u/', '')
    styleNotify = '/n/' in line
    line = line.replace('/n/', '')
    w, h = width * len(line) + len(line), height
  
    xi = x
    yi = y + (i*vspacing)
    
    if halign == -1:
      xi = x - w + 2
    elif halign == 0:
      xi = x - (w / 2) + 1
      
    if valign == 1:
      yi = yi + (h * i)
    elif valign == -1:
      yi = yi + (h * i) - (h * (str.count('\n')+1))
      #yi = yi - (str.count('\n') * h) - (h * i) - i + 1
    elif valign == 0:
      yi = yi + (h * i) - (h * (str.count('\n')+1))/2
      
    for char in line:
      yoffset = 0 if char not in mfData else mfData[char].get('yoffset', 0)
      xoffset = 0 if char not in mfData else mfData[char].get('xoffset', 0)
      
      drawByteChar(imageArr, arr[char], xi + xoffset, yi + yoffset, width, height, fill)
      xi += width + padding

    if styleBlock:
      Backend.drawInvertRectangleSize({
        'x1': 0,
        'y1': yi - 1,
        'height': 7,
        'imageArr': imageArr,
        'fill': fill
      })
      
    if styleUnderdash:
      Backend.drawLineDashHor({
        'x': 0,
        'y': yi + 6,
        'fill': fill
      })
      
    if styleUnderline:
      Backend.drawLine({
        'x1': 0,
        'y1': yi + 6,
        'y2': yi + 6,
        'fill': fill
      })
      
    if styleNotify:
      xPos = Backend.getWidth()
      draw.polygon([(xPos - 5, yi), (xPos - 1, yi), (xPos - 1, yi + 4)], outline=255, fill=fill)
    
    i += 1

def processCommandSingle(data):
  Backend.message = None;

  if not data['r']:
    Backend.handle(data['function'], data['args'])
    return

  Backend.message = {
    "type": 'r',
    "id": data['id'],
    "funct": data['function']
  };

  ########print('________' + data['function'])
  result = Backend.handle(data['function'], data['args'])
  Backend.message['value'] = result;
  
  print(json.dumps(Backend.message))
  """Backend.message = {
    "type": 'r',
    "id": data['id']
  };
  result = Backend.handle(data['function'], data['args'])
    
  if data['r']:
    Backend.message['value'] = result if result else None
    #"value": result if result else None
    
  #print('_',json.dumps(Backend.message))
  print(json.dumps(Backend.message))"""

def listen():
  t = 0
  quit = False
  global image
  while not quit:
    try:
      if Backend.resetFlag:
        #printError('Restarting display.', True);
        #print('Bus restarting')
        time.sleep(1)
        #disp.reset()
        Backend.reinit({})
        #disp.clear()
        Backend.render({});
        #printError('Restarted display.', True);
        #print('Bus restarted')
        #disp.display()
          
        Backend.resetFlag = False
        Backend.readyFlag = True
        
        if (Backend.message):
          Backend.message['value'] = False
          print(json.dumps(Backend.message))
        continue
      
      command = sys.stdin.readline()
      command = command.split('\n')[0]
      if command:
        data = json.loads(command)
        
        if 'single' == data.get('type', 'single'):
          processCommandSingle(data)
        else:
          dataQueue = json.loads(data['queue'])
          for temp in dataQueue:
            processCommandSingle(temp)

    except (KeyboardInterrupt, SystemExit):
      quit = True
    except OSError as e:
      # Display error
      Backend.resetFlag = True
    except Exception as e:
      # Other exception
      Backend.resetFlag = True
      #exc_type, exc_obj, exc_tb = sys.exc_info()
      print(str(e))
      print('ERR', traceback.print_exc(), str(e), exc_type, exc_tb.tb_lineno)
      print({
        "type": "exception",
        "message": str(e)
      })
      quit = True
    """except BackendException as e:
      print({
        "type": "python_error",
        "message": str(e)
      })
      sys.exit(1)"""
      
    """
    print({
        "type": "exception",
        "id": "123432",
        "message": str(e)
      })
      
    except Exception as e:
      reset = True
      exc_type, exc_obj, exc_tb = sys.exc_info()
      print(exc_type, fname, exc_tb.tb_lineno)
      print(str(e))
      success = False
      while not success and not quit:
        try:
          print('Bus restarting')
          time.sleep(1)
          disp.begin()
          success = True
          print('Bus restarted')
        except:
          pass"""
        

if __name__ == '__main__':
  args = json.loads(sys.argv[1])
  listen()